<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Note</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="Wesely Note">
    <link rel="preload" href="/NotePro/assets/css/0.styles.84c2a560.css" as="style"><link rel="preload" href="/NotePro/assets/js/app.842cebdb.js" as="script"><link rel="preload" href="/NotePro/assets/js/2.51c83669.js" as="script"><link rel="preload" href="/NotePro/assets/js/12.8c45ba99.js" as="script"><link rel="prefetch" href="/NotePro/assets/js/10.74f417bc.js"><link rel="prefetch" href="/NotePro/assets/js/11.ede4817e.js"><link rel="prefetch" href="/NotePro/assets/js/13.e1e9951c.js"><link rel="prefetch" href="/NotePro/assets/js/14.dde976bf.js"><link rel="prefetch" href="/NotePro/assets/js/15.638eb3b0.js"><link rel="prefetch" href="/NotePro/assets/js/16.281e02be.js"><link rel="prefetch" href="/NotePro/assets/js/17.5483bdb8.js"><link rel="prefetch" href="/NotePro/assets/js/18.0fdae569.js"><link rel="prefetch" href="/NotePro/assets/js/19.9350b2bc.js"><link rel="prefetch" href="/NotePro/assets/js/3.3a265e35.js"><link rel="prefetch" href="/NotePro/assets/js/4.678c9681.js"><link rel="prefetch" href="/NotePro/assets/js/5.4f80a4a4.js"><link rel="prefetch" href="/NotePro/assets/js/6.9517a1cc.js"><link rel="prefetch" href="/NotePro/assets/js/7.4215e4a4.js"><link rel="prefetch" href="/NotePro/assets/js/8.b1ddaf20.js"><link rel="prefetch" href="/NotePro/assets/js/9.56e85243.js">
    <link rel="stylesheet" href="/NotePro/assets/css/0.styles.84c2a560.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/NotePro/" class="home-link router-link-active"><!----> <span class="site-name">Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/NotePro/" class="nav-link">
  主页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/NotePro/" class="nav-link">
  主页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/NotePro/notes/React/react.html" class="sidebar-link">React笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#react" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#状态组件" class="sidebar-link">- 状态组件</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#数据是向下流动的-单向数据流" class="sidebar-link">- 数据是向下流动的 (单向数据流)</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#受控组件-状态提升" class="sidebar-link">- 受控组件[状态提升]</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#组合-vs-继承" class="sidebar-link">- 组合 vs 继承</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#context" class="sidebar-link">- context *</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#refs" class="sidebar-link">- Refs</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#高阶组件" class="sidebar-link">- 高阶组件</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#portals" class="sidebar-link">- Portals  *</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#render-props" class="sidebar-link">- Render Props</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#严格模式" class="sidebar-link">- 严格模式 :</a></li></ul></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/React/react.html#redux-saga" class="sidebar-link">Redux-saga</a></li></ul></li><li><a href="/NotePro/notes/React/react-source.html" class="sidebar-link">React源码解析</a></li><li><a href="/NotePro/notes/Vue/vue.html" class="sidebar-link">Vue笔记</a></li><li><a href="/NotePro/notes/Vue/vue-source.html" class="sidebar-link">Vue源码解析</a></li><li><a href="/NotePro/notes/Flutter/" class="sidebar-link">Flutter笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/Flutter/#flutter" class="sidebar-link">Flutter</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter源码解析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Backbone源码解析</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/NotePro/notes/Browser/" class="sidebar-link">浏览器相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/Browser/#browser" class="sidebar-link">Browser</a></li></ul></li><li><a href="/NotePro/notes/Measure/" class="sidebar-link">CI/DI</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/Measure/#前端自动化分类" class="sidebar-link">前端自动化分类</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/Measure/#前端自动化实践" class="sidebar-link">前端自动化实践</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack相关</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/NotePro/notes/Other/" aria-current="page" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/Other/#本地npm库搭建-自己的服务器" class="sidebar-link">本地npm库搭建[自己的服务器]</a></li></ul></li><li><a href="/NotePro/notes/CSS/" class="sidebar-link">CSS/CSS3</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>组件化组件</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/NotePro/notes/Performance/" class="sidebar-link">性能调优</a></li><li><a href="/NotePro/notes/Ast/" class="sidebar-link">AST</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NotePro/notes/Ast/#ast树" class="sidebar-link">AST树</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/Ast/#javascript-编译" class="sidebar-link">javascript 编译</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/Ast/#javascript引擎" class="sidebar-link">JavaScript引擎</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/Ast/#webassemble" class="sidebar-link">WebAssemble</a></li><li class="sidebar-sub-header"><a href="/NotePro/notes/Ast/#llvm" class="sidebar-link">LLVM</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SOA/微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python实战案例</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java实战案例</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Go笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Go实战案例</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>1、prototype和__proto__的关系是什么？
所有对象都有__proto__属性，函数这个特殊对象除了具有__proto__属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。</p> <p>2、meta viewport原理是什么？</p> <p>3、域名收敛是什么？</p> <p>4、float和display:inline-block的区别是什么？</p> <p>6、首屏、白屏时间如何计算？</p> <p>7、解释一下闭包</p> <p>8、解释一下作用域链</p> <p>9、ajax如何实现，readyState的五种状态的含义？</p> <p>10、jsonp如何实现？</p> <p>11、怎么处理跨域？</p> <p>12、restful的method解释？</p> <p>14、事件模型解释</p> <p>41、如何用NodeJS搭建中间层？</p> <p>42、vue与react的对比,如何选型？从性能，生态圈，数据量，数据的传递上，作比较</p> <p>43、vue slot是做什么的?</p> <p>45、vue路由实现原理?</p> <p>29、什么是代理和通知，写一下他们基本的实现方</p> <p>31、rem布局字体太大怎么处理?</p> <p>33、微信支付怎么做？说说流程</p> <ol start="5"><li><p>样式的层级关系，选择器优先级，样式冲突，以及抽离样式模块怎么写，说出思路，有无实践经验</p></li> <li><p>css3动画效果属性，canvas、svg的区别，CSS3中新增伪类举例</p></li> <li><p>怎样避免全局变量污染?ES5严格模式的作用，ES6箭头函数和ES5普通函数一样吗?</p></li> <li><p>说一下了解的js 设计模式，解释一下单例、工厂、观察者。</p></li> <li><p>从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好。</p></li> <li><p>介绍一下webpack webpack</p> <p>1.React 中 keys 的作用是什么？
在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联关系,因此我们在开发中不可忽视Key值的使用.</p></li></ol> <p>2.React 中 refs 的作用是什么？
Refs是React提供给我们安全的访问DOM元素或者某个组件实例的句柄,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回.
    3.React 中有三种构建组件的方式
无状态函数式组件
组件不会被实例化，整体渲染性能得到提升
组件不能访问this对象
组件无法访问生命周期的方法
无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用
React.createClass
组件在插入页面前其实是在虚拟 DOM 中的表示，因此，在渲染成最终实际的 DOM 前，不能通过直接访问组件内的元素来试图获取它的属性。
React.createClass会自绑定函数方法导致不必要的性能开销
React.createClass的mixins不够自然、直观
React.Component
React.Component三种手动绑定this的方法
在构造函数中绑定
使用bind绑定
</p><div onKeyUp="{this.Enter.bind(this)}"></div>
使用arrow function绑定<p></p> <p>4.调用 setState 之后发生了什么？
当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解的最终目标是以最有效的方式，根据这个新的状态来更新UI。
为此，React将构建一个新的 React 元素树。一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React会将这个新树与上一个元素树相比较（ diff ）。
通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新最小化UI的占用空间。</p> <p>5.react diff 原理（常考，大厂必考）
React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度
策略一（tree diff）：
Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。
策略二（component diff）：
拥有相同类的两个组件 生成相似的树形结构，
拥有不同类的两个组件 生成不同的树形结构。
策略三（element diff）：
对于同一层级的一组子节点，通过唯一id区分。
（1）React通过updateDepth对Virtual DOM树进行层级控制。
（2）对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。
（3）只需遍历一次，就能完成整棵DOM树的比较。</p> <div class="language- extra-class"><pre><code>  component diff
  如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树即可。
  如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。
  对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析，但是如果调用了forceUpdate方法，shouldComponentUpdate则失效。 

  element diff
  INSERT_MARKUP :新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作。
  MOVE_EXISTING :旧集合中有新组件类型，且 element 是可更新的类型，generateComponentChildren 已调用receiveComponent ，这种情况下 prevChild=nextChild ，就需要做移动操作，可以复用以前的 DOM 节点。
  REMOVE_NODE :旧组件类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。
</code></pre></div><p>6.为什么建议传递给 setState 的参数是一个 callback 而不是一个对象
因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。
    7.除了在构造函数中绑定 this，还有其它方式吗
构造函数、bind、箭头函数
    8.setState第二个参数的作用
setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成
    9.(在构造函数中)调用 super(props) 的目的是什么
调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用this
super(props)的目的：在constructor中可以使用this.props
constructor会覆盖父类的constructor，导致你父类构造函数没执行
    10.简述 flux 思想
Flux 的最大特点，就是数据的&quot;单向流动&quot;。
1.用户访问 View
2.View 发出用户的 Action
3.Dispatcher 收到 Action，要求 Store 进行相应的更新
4.Store 更新后，发出一个&quot;change&quot;事件
5.View 收到&quot;change&quot;事件后，更新页面
    11.在 React 当中 Element 和 Component 有何区别？
ReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合.
ReactComponent则是可以接收参数输入并且返回某个ReactElement的函数或者类.
    12.描述事件在 React 中的处理方式。</p> <p>13.createElement 和 cloneElement 有什么区别？
react.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数element是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。将保留原始元素的键和引用
    14.如何告诉 React 它应该编译生产环境版本？
通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。</p> <p>15.Controlled Component 与 Uncontrolled Component 之间的区别是什么？
受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。
非受控组件（Uncontrolled Component）则是由DOM存放表单数据，并非存放在 React 组件中。我们可以使用 refs 来操控DOM元素</p> <div class="language- extra-class"><pre><code>1.展示组件(Presentational component)和容器组件(Container component)之间有何不同
  展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。(子组件)
  容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。(父组件)
</code></pre></div><p>2.类组件(Class component)和函数式组件(Functional component)之间有何不同
类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态
当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件
    3.(组件的)状态(state)和属性(props)之间有何不同
State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。
Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。
    4.何为受控组件(controlled component)
    5.何为高阶组件(higher order component)
HOC 看作是参数化的容器组件的定义
高阶组件就是函数将一个组件作为参数，然后再返回一个组件
const EnhancedComponent = higherOrderComponent(WrappedComponent);
一个组件是 React 复用代码的最小单元，但是你会发现一些模式并不能直接被传统的组件套用。
    6.应该在 React 组件的何处发起 Ajax 请求
我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：
　　React 下一代调和算法 Fiber 会通圌过开始或停止渲染的方式优化应用性能，其会影响到 componenТWillMount 的触发次数。对于 componenТWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componenТWillMount。如果我们将 AJAX 请求放到 componenТWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。
　　如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题
    7.react中组件传值
    8.什么时候在功能组件( Class Component )上使用类组件( Functional Component )？
如果您的  组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件
    10.react 组件的划分业务组件技术组件？</p> <div class="language- extra-class"><pre><code>1.redux中间件
2.redux有什么缺点
  1、 action和reducer太繁琐。一套或者几套action和reducer的组合，看起来很不错，但是一旦功能和需求多了，action和reducer就会很混乱，如果管理不善，都不能愉悦的写代码了。比如你一个人开发你自己的博客的时候，独自面对大量的action和reducer和store，不知道会不会头疼。所以redux是不适合小场景的。微服务好，也不是什么系统都适合的。

  2、store和state的模棱两可。没有严格的定义哪些存store，哪些存internal state。如果不是资深redux玩家，想必也说不出个所以然来。

  3、dispatch是同步的，而且dispatch没办法确认action是否执行成功
3.了解 redux 么，说一下 redux 把

1.vue和react的区别
</code></pre></div><p>2.react性能优化的方案
    3.React 项目用过什么脚手架
    4.介绍一下webpack webpack</p> <p>6.为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？
7.all、apply以及bind函数内部实现是怎么样的
Function.prototype.bind = function(thisArg) {
if(typeof this !== 'function'){
throw new TypeError(this + 'must be a function');
}
// 存储函数本身
const _this  = this;
// 去除thisArg的其他参数 转成数组
const args = [...arguments].slice(1)
// 返回一个函数
const bound = function() {
// 可能返回了一个构造函数，我们可以 new F()，所以需要判断
if (this instanceof bound) {
return new _this(...args, ...arguments)
}
// apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果
return _this.apply(thisArg, args.concat(...arguments))
}
return bound
}
8.Canvas和SVG有什么区别
SVG
　　　　SVG 是一种使用 XML 描述 2D 图形的语言。
　　　　SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
　　　　在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
　　　　特点：
　　　　	　　不依赖分辨率
　　　　	　　支持事件处理器
　　　　	　　最适合带有大型渲染区域的应用程序（比如谷歌地图）
　　　　　　	复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
　　　　	　　不适合游戏应用
　　Canvas
　　　　Canvas 通过 JavaScript 来绘制 2D 图形。
　　　　Canvas 是逐像素进行渲染的。
　　　　在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
　　　　特点：
　　　    　　依赖分辨率
　　　　	　　不支持事件处理器
　　　　　　	弱的文本渲染能力
　　　　　　	能够以 .png 或 .jpg 格式保存结果图像
　　　　	　　最适合图像密集型的游戏，其中的许多对象会被频繁重绘</p> <p>https://www.jianshu.com/p/e9521f78d51e
http://www.sohu.com/a/228045621_647584
https://www.cnblogs.com/Yanss/p/10135405.html
https://www.jianshu.com/p/4357c4ae99eb
https://segmentfault.com/a/1190000015648248?utm_source=tag-newest</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/NotePro/assets/js/app.842cebdb.js" defer></script><script src="/NotePro/assets/js/2.51c83669.js" defer></script><script src="/NotePro/assets/js/12.8c45ba99.js" defer></script>
  </body>
</html>
