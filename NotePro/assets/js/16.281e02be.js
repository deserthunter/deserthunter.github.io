(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{362:function(t,n,e){"use strict";e.r(n);var s=e(43),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("h3",{attrs:{id:"状态组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态组件"}},[t._v("#")]),t._v(" - 状态组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(" react 中的组件分为无状态组件和有状态组件两类。\n > 无状态组件\n 无状态组件主要用来定义模板，接收来自父组件props传递过来的数据.无状态组件保持模板的纯粹性，以便于组件复用.\n ```\n var Header = (props) = (\n\t    <div>{props.xxx}</div>\n\t);\n ```\n > 有状态的组件(也叫容器组件)\n 有状态组件用来定义交互逻辑和业务数据。通过state管理数据状态.\n ```\n class Home extends React.Component {\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t            nameOne: props.name,\n\t            nameTwo: this.props.name \n\t        }\n\t    };\n\t    render() {\n\t        return (\n\t            <div>{this.state.nameOne}{this.state.nameTwo}</div>\n\t        )\n\t    }\n\t}\n ```\n")])])]),e("h3",{attrs:{id:"数据是向下流动的-单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据是向下流动的-单向数据流"}},[t._v("#")]),t._v(" - 数据是向下流动的 (单向数据流)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("\t父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。\n\t任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI只能影响树中下方的组件（状态通常被认为是局部或封装在一个组件。除了拥有并设置它的组件外，其它组件不可访问）。组件间得知状态，也只能通过父子组件间的通信实现.\n\t```\n\tfunction FormattedDate(props) {\n\t  return <h2>现在是 {props.date.toLocaleTimeString()}.</h2>;\n\t}\n\t \n\tclass Clock extends React.Component {\n\t  constructor(props) {\n\t    super(props);\n\t    this.state = {date: new Date()};\n\t  }\n\t \n\t  componentDidMount() {\n\t    this.timerID = setInterval(\n\t      () => this.tick(),\n\t      1000\n\t    );\n\t  }\n\t \n\t  componentWillUnmount() {\n\t    clearInterval(this.timerID);\n\t  }\n\t \n\t  tick() {\n\t    this.setState({\n\t      date: new Date()\n\t    });\n\t  }\n\t \n\t  render() {\n\t    return (\n\t      <div>\n\t        <h1>Hello, world!</h1>\n\t        <FormattedDate date={this.state.date} />\n\t      </div>\n\t    );\n\t  }\n\t}\n\t \n\tReactDOM.render(\n\t  <Clock />,\n\t  document.getElementById('example')\n\t);\n\t```\n")])])]),e("h3",{attrs:{id:"受控组件-状态提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#受控组件-状态提升"}},[t._v("#")]),t._v(" - 受控组件[状态提升]")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("\t> 受控组件\n\t值由React控制的输入表单元素称为“受控组件”。\n\t受控组件有两个特点：1. 设置value值，value由state控制，2. value值一般在onChange事件中通过setState进行修改\n\t> 非受控组件\n\t任何时候都不需要改变组件的value值，这时候可以使用非受控组件\n")])])]),e("h3",{attrs:{id:"组合-vs-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合-vs-继承"}},[t._v("#")]),t._v(" - 组合 vs 继承")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('\t> 组合\n\t有点类似vue的插槽。\n\t```\n\tfunction SplitPane(props) {\n\t  return (\n\t    <div className="SplitPane">\n\t      <div className="SplitPane-left">\n\t        {props.left}\n\t      </div>\n\t      <div className="SplitPane-right">\n\t        {props.right}\n\t      </div>\n\t    </div>\n\t  );\n\t}\n\n\tfunction App() {\n\t  return (\n\t    <SplitPane\n\t      left={\n\t        <Contacts />\n\t      }\n\t      right={\n\t        <Chat />\n\t      } />\n\t  );\n\tReactDOM.render(<Slot>测试简单插槽</Slot>,document.getElementById(\'root\'))\n\t```\n\t> 继承\n\tProps 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。\n\t注意：目前并没有发现需要使用继承的地方\n')])])]),e("h3",{attrs:{id:"context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" - context *")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("\tJS中context指的是函数的执行上下文，函数被调用时，this指向谁，谁就是当前的执行上下文；\n\treact中的context是:\n\tContext 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性. 也就是说可以使用context实现跨层级进行数据传递。\n\tcontext api给出三个概念：React.createContext()、Provider、Consumer。\n\t注意：值得一提的是每当Provider的值发生改变时, 作为Provider后代的所有Consumers都会重新渲染。\n\t类似vue 的provider 和 inject\n")])])]),e("h3",{attrs:{id:"refs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[t._v("#")]),t._v(" - Refs")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('\treact中，可以使用refs来访问dom，或者在render中创建react对象.\n\t使用refs的方式有两种，一种是使用React.createRef() API，另一种是使用 回调形式的refs(eact 将在组件挂载时，会调用 ref 回调函数并传入 DOM 元素，当卸载时调用它并传入 null。在 componentDidMount 或 componentDidUpdate 触发前，React 会保证 refs 一定是最新的).\n\t```\n\timport React, { Component } from \'react\'\n\texport default class App extends React.Component {\n\t  constructor(props) {\n\t    super(props);\n\t    // 创建一个 ref 来存储 textInput 的 DOM 元素\n\t    this.textInput = React.createRef();\n\t    this.focusTextInput = this.focusTextInput.bind(this);\n\t  }\n\n\t  focusTextInput() {\n\t    // 直接使用原生 API 使 text 输入框获得焦点\n\t    // 注意：我们通过 "current" 来访问 DOM 节点\n\t    this.textInput.current.focus();\n\t    console.log(this.textInput.current);//这边输出input的dom对象\n\t  }\n\n\t  render() {\n\t    // 告诉 React 我们想把 <input> ref 关联到\n\t    // 构造器里创建的 `textInput` 上\n\t    return (\n\t      <div>\n\t        <input\n\t          type="text"\n\t          ref={this.textInput} />\n\n\t        <input\n\t          type="button"\n\t          value="点击我获取焦点"\n\t          onClick={this.focusTextInput}\n\t        />\n\t      </div>\n\t    );\n\t   }\n\t }\n\t```\n\t```\n\timport React, { Component } from \'react\'\n\texport default class App extends React.Component {\n\t  constructor(props) {\n\t    super(props);\n\t    // 创建一个 ref 来存储 textInput 的 DOM 元素\n\t    this.textInput = null;\n\t    this.setTextInputRef = element => {\n\t      this.textInput = element;\n\t    };\n\t    this.focusTextInput = () => {\n\t      // 使用原生 DOM API 使 text 输入框获得焦点\n\t      if (this.textInput) this.textInput.focus();\n\t    };\n\t  }\n\n\t  componentDidMount() {\n\t    // 组件挂载后，让文本框自动获得焦点\n\t    this.focusTextInput();\n\t  }\n\n\t  render() {\n\t    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React\n\t    // 实例上（比如 this.textInput）\n\t    return (\n\t      <div>\n\t        <input\n\t          type="text"\n\t          ref={this.setTextInputRef}\n\t        />\n\t        <input\n\t          type="button"\n\t          value="点击我获取焦点"\n\t          onClick={this.focusTextInput}\n\t        />\n\t      </div>\n\t    );\n\t  }\n\t}\n\t```\n')])])]),e("h3",{attrs:{id:"高阶组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" - 高阶组件")]),t._v(" "),e("blockquote",[e("p",[t._v("封装其他组件返回 匿名class，render禁用hoc\n高阶组件接收React组件作为参数，并且返回一个新的React组件。高阶组件本质上也是一个函数，并不是一个组件，这一点一定不要弄错。")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\timport React, { Component } from 'react'\n  function withPersistentData(WrappedComponent) {\n    return class extends Component {\n      componentWillMount() {\n        let data = localStorage.getItem('data');\n          this.setState({data});\n      }\n      render() {\n        // 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\n        return <WrappedComponent data={this.state.data} {...this.props} />\n      }\n    }\n  }\n\n  class MyComponent2 extends Component {  \n    render() {\n      return <div>{this.props.data}</div>\n    }\n  }\n  const MyComponentWithPersistentData = withPersistentData(MyComponent2)\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br")])]),e("h3",{attrs:{id:"portals"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#portals"}},[t._v("#")]),t._v(" - Portals  *")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("使得组件可以脱离父组件层级挂载在DOM树的任何位置,但是事件冒泡可以传递到父组件.\n使得组件可以脱离父组件层级挂载在DOM树的任何位置\n```\nconst appRoot = document.getElementById('app-root');\nconst modalRoot = document.getElementById('modal-root');\n\nclass Modal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.el = document.createElement('div');\n  }\n\n  componentDidMount() {\n    modalRoot.appendChild(this.el);\n  }\n\n  componentWillUnmount() {\n    modalRoot.removeChild(this.el);\n  }\n\n  render() {\n    return ReactDOM.createPortal(\n      this.props.children,\n      this.el,\n    );\n  }\n}\n\nclass Parent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {clicks: 0};\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // This will fire when the button in Child is clicked,\n    // updating Parent's state, even though button\n    // is not direct descendant in the DOM.\n    this.setState(prevState => ({\n      clicks: prevState.clicks + 1\n    }));\n  }\n\n  render() {\n    return (\n      <div onClick={this.handleClick}>\n        <p>Number of clicks: {this.state.clicks}</p>\n        <p>\n          Open up the browser DevTools\n          to observe that the button\n          is not a child of the div\n          with the onClick handler.\n        </p>\n        <Modal>\n          <Child />\n        </Modal>\n      </div>\n    );\n  }\n}\n\nfunction Child() {\n  // The click event on this button will bubble up to parent,\n  // because there is no 'onClick' attribute defined\n  return (\n    <div className=\"modal\">\n      <button>Click</button>\n    </div>\n  );\n}\n\nReactDOM.render(<Parent />, appRoot);\n```\n")])])]),e("h3",{attrs:{id:"render-props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render-props"}},[t._v("#")]),t._v(" - Render Props")]),t._v(" "),e("blockquote",[e("p",[t._v("共享state")])]),t._v(" "),e("h3",{attrs:{id:"严格模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[t._v("#")]),t._v(" - 严格模式 :")]),t._v(" "),e("blockquote",[e("p",[t._v("StrictMode")])]),t._v(" "),e("h2",{attrs:{id:"redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),e("blockquote",[e("p",[t._v("http://cn.redux.js.org")])]),t._v(" "),e("h2",{attrs:{id:"redux-saga"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-saga"}},[t._v("#")]),t._v(" Redux-saga")]),t._v(" "),e("blockquote",[e("p",[t._v("https://redux-saga-in-chinese.js.org/\nRedux-saga 使用步骤")])]),t._v(" "),e("ol",[e("li",[t._v("定义action. eg:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("```\nimport * as types from '../constants'\nexport const getActionTopicMedias = (text) =>{\n  return {type:types.topic_list,topiclist:text||[]}\n} \n\nexport const actionTopicMeidasSuccess =  (text) => {\n  return {type:types.topic_list_success,topiclist:text||[]};\n}\n```\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("定义reducer. eg:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('```\nimport { combineReducers } from "redux";\nexport function getMediaList(state = {medialist:[],topiclist:[]},action){\n  return {\n    ...state,\n    ...action\n  }\n}\n```\n')])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("定义 sagas. eg:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("```\nimport {put,takeEvery,call,all,fork} from 'redux-saga/effects'\nimport {getSliderMedias,getTopicList,getMovieDetail,getMovieInterCommond,getMovieTopic}  from '../../api'\nimport * as types from '../constants'\nimport * as actions from '../action'\n\nfunction* watchRequestMeidaList () {\n  yield takeEvery(types.media_list, getMiddleMediaList)\n}\n\nfunction* getMiddleMediaList(){\n  const result = yield call(getSliderMedias);\n  if(!result.data.code){\n    yield put(actions.actionSliderMeidasSuccess(result.data.data||[]))\n  }\n}\n\nfunction* rootSaga(){\n    yield all([fork(watchRequestMeidaList)])\n}\n\nexport default rootSaga;\n```\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("链接saga 和 reducer")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("```\nimport {createStore,applyMiddleware,compose} from 'redux';\nimport rootReducer from './reducers';\n\nimport createSagaMiddleware from 'redux-saga'\nimport rootSaga from './sagas/'\n\nexport  function configureStoreSaga(preloadState) {\n  const sagaMiddleware = createSagaMiddleware();\n  const store = createStore(rootReducer,applyMiddleware(sagaMiddleware));\n  sagaMiddleware.run(rootSaga);\n  return store;\n}\n```\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("组件绑定 状态")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("```\nclass MovieList extends Component {\n  constructor(props){\n    super(props);\n    let {medialist, topiclist} = this.props\n    if(medialist && !medialist.length){\n      this.props.setMediaList();\n    }\n    if(topiclist && !topiclist.length){\n      this.props.setTopicList();\n    }\n  }\n  doneClick = () => {\n    console.log(this.props);\n  }\n  render(){\n    let {medialist, topiclist} = this.props;\n    let swiperlist = [];\n    medialist.forEach(item => {\n      if(!item.ad){\n        swiperlist.push({source:item.pic2,title:item.name});\n      }\n    });\n    return (\n      <div>\n        <Mslider sources={swiperlist} interval={3000} number={swiperlist.length} activeIndex={0}>\n        </Mslider>\n        <Mtopic sources={topiclist}></Mtopic>\n      </div>\n    )\n  }\n}\n\nexport default connect((state) => {\n  return state.getMediaList\n},(dispatch) => {\n  return {\n    setMediaList: (text) => dispatch(getActionSliderMedias(text)),\n    setTopicList: (text) => dispatch(getActionTopicMedias(text))\n  }\n})(MovieList)\n```\t")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);