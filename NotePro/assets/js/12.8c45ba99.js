(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{359:function(n,t,e){"use strict";e.r(t);var o=e(43),a=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("1、prototype和__proto__的关系是什么？\n所有对象都有__proto__属性，函数这个特殊对象除了具有__proto__属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。")]),n._v(" "),e("p",[n._v("2、meta viewport原理是什么？")]),n._v(" "),e("p",[n._v("3、域名收敛是什么？")]),n._v(" "),e("p",[n._v("4、float和display:inline-block的区别是什么？")]),n._v(" "),e("p",[n._v("6、首屏、白屏时间如何计算？")]),n._v(" "),e("p",[n._v("7、解释一下闭包")]),n._v(" "),e("p",[n._v("8、解释一下作用域链")]),n._v(" "),e("p",[n._v("9、ajax如何实现，readyState的五种状态的含义？")]),n._v(" "),e("p",[n._v("10、jsonp如何实现？")]),n._v(" "),e("p",[n._v("11、怎么处理跨域？")]),n._v(" "),e("p",[n._v("12、restful的method解释？")]),n._v(" "),e("p",[n._v("14、事件模型解释")]),n._v(" "),e("p",[n._v("41、如何用NodeJS搭建中间层？")]),n._v(" "),e("p",[n._v("42、vue与react的对比,如何选型？从性能，生态圈，数据量，数据的传递上，作比较")]),n._v(" "),e("p",[n._v("43、vue slot是做什么的?")]),n._v(" "),e("p",[n._v("45、vue路由实现原理?")]),n._v(" "),e("p",[n._v("29、什么是代理和通知，写一下他们基本的实现方")]),n._v(" "),e("p",[n._v("31、rem布局字体太大怎么处理?")]),n._v(" "),e("p",[n._v("33、微信支付怎么做？说说流程")]),n._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[e("p",[n._v("样式的层级关系，选择器优先级，样式冲突，以及抽离样式模块怎么写，说出思路，有无实践经验")])]),n._v(" "),e("li",[e("p",[n._v("css3动画效果属性，canvas、svg的区别，CSS3中新增伪类举例")])]),n._v(" "),e("li",[e("p",[n._v("怎样避免全局变量污染?ES5严格模式的作用，ES6箭头函数和ES5普通函数一样吗?")])]),n._v(" "),e("li",[e("p",[n._v("说一下了解的js 设计模式，解释一下单例、工厂、观察者。")])]),n._v(" "),e("li",[e("p",[n._v("从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好。")])]),n._v(" "),e("li",[e("p",[n._v("介绍一下webpack webpack")]),n._v(" "),e("p",[n._v("1.React 中 keys 的作用是什么？\n在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联关系,因此我们在开发中不可忽视Key值的使用.")])])]),n._v(" "),e("p",[n._v("2.React 中 refs 的作用是什么？\nRefs是React提供给我们安全的访问DOM元素或者某个组件实例的句柄,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回.\n    3.React 中有三种构建组件的方式\n无状态函数式组件\n组件不会被实例化，整体渲染性能得到提升\n组件不能访问this对象\n组件无法访问生命周期的方法\n无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用\nReact.createClass\n组件在插入页面前其实是在虚拟 DOM 中的表示，因此，在渲染成最终实际的 DOM 前，不能通过直接访问组件内的元素来试图获取它的属性。\nReact.createClass会自绑定函数方法导致不必要的性能开销\nReact.createClass的mixins不够自然、直观\nReact.Component\nReact.Component三种手动绑定this的方法\n在构造函数中绑定\n使用bind绑定\n")]),e("div",{attrs:{onKeyUp:"{this.Enter.bind(this)}"}}),n._v("\n使用arrow function绑定"),e("p"),n._v(" "),e("p",[n._v("4.调用 setState 之后发生了什么？\n当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解的最终目标是以最有效的方式，根据这个新的状态来更新UI。\n为此，React将构建一个新的 React 元素树。一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React会将这个新树与上一个元素树相比较（ diff ）。\n通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新最小化UI的占用空间。")]),n._v(" "),e("p",[n._v("5.react diff 原理（常考，大厂必考）\nReact用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度\n策略一（tree diff）：\nWeb UI中DOM节点跨层级的移动操作特别少，可以忽略不计。\n策略二（component diff）：\n拥有相同类的两个组件 生成相似的树形结构，\n拥有不同类的两个组件 生成不同的树形结构。\n策略三（element diff）：\n对于同一层级的一组子节点，通过唯一id区分。\n（1）React通过updateDepth对Virtual DOM树进行层级控制。\n（2）对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。\n（3）只需遍历一次，就能完成整棵DOM树的比较。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("  component diff\n  如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树即可。\n  如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。\n  对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析，但是如果调用了forceUpdate方法，shouldComponentUpdate则失效。 \n\n  element diff\n  INSERT_MARKUP :新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作。\n  MOVE_EXISTING :旧集合中有新组件类型，且 element 是可更新的类型，generateComponentChildren 已调用receiveComponent ，这种情况下 prevChild=nextChild ，就需要做移动操作，可以复用以前的 DOM 节点。\n  REMOVE_NODE :旧组件类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。\n")])])]),e("p",[n._v('6.为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n    7.除了在构造函数中绑定 this，还有其它方式吗\n构造函数、bind、箭头函数\n    8.setState第二个参数的作用\nsetState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成\n    9.(在构造函数中)调用 super(props) 的目的是什么\n调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用this\nsuper(props)的目的：在constructor中可以使用this.props\nconstructor会覆盖父类的constructor，导致你父类构造函数没执行\n    10.简述 flux 思想\nFlux 的最大特点，就是数据的"单向流动"。\n1.用户访问 View\n2.View 发出用户的 Action\n3.Dispatcher 收到 Action，要求 Store 进行相应的更新\n4.Store 更新后，发出一个"change"事件\n5.View 收到"change"事件后，更新页面\n    11.在 React 当中 Element 和 Component 有何区别？\nReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合.\nReactComponent则是可以接收参数输入并且返回某个ReactElement的函数或者类.\n    12.描述事件在 React 中的处理方式。')]),n._v(" "),e("p",[n._v("13.createElement 和 cloneElement 有什么区别？\nreact.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数element是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。将保留原始元素的键和引用\n    14.如何告诉 React 它应该编译生产环境版本？\n通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。")]),n._v(" "),e("p",[n._v("15.Controlled Component 与 Uncontrolled Component 之间的区别是什么？\n受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。\n非受控组件（Uncontrolled Component）则是由DOM存放表单数据，并非存放在 React 组件中。我们可以使用 refs 来操控DOM元素")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1.展示组件(Presentational component)和容器组件(Container component)之间有何不同\n  展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。(子组件)\n  容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。(父组件)\n")])])]),e("p",[n._v("2.类组件(Class component)和函数式组件(Functional component)之间有何不同\n类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态\n当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n    3.(组件的)状态(state)和属性(props)之间有何不同\nState 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\nProps(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。\n    4.何为受控组件(controlled component)\n    5.何为高阶组件(higher order component)\nHOC 看作是参数化的容器组件的定义\n高阶组件就是函数将一个组件作为参数，然后再返回一个组件\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n一个组件是 React 复用代码的最小单元，但是你会发现一些模式并不能直接被传统的组件套用。\n    6.应该在 React 组件的何处发起 Ajax 请求\n我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：\n　　React 下一代调和算法 Fiber 会通圌过开始或停止渲染的方式优化应用性能，其会影响到 componenТWillMount 的触发次数。对于 componenТWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componenТWillMount。如果我们将 AJAX 请求放到 componenТWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。\n　　如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题\n    7.react中组件传值\n    8.什么时候在功能组件( Class Component )上使用类组件( Functional Component )？\n如果您的  组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件\n    10.react 组件的划分业务组件技术组件？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1.redux中间件\n2.redux有什么缺点\n  1、 action和reducer太繁琐。一套或者几套action和reducer的组合，看起来很不错，但是一旦功能和需求多了，action和reducer就会很混乱，如果管理不善，都不能愉悦的写代码了。比如你一个人开发你自己的博客的时候，独自面对大量的action和reducer和store，不知道会不会头疼。所以redux是不适合小场景的。微服务好，也不是什么系统都适合的。\n\n  2、store和state的模棱两可。没有严格的定义哪些存store，哪些存internal state。如果不是资深redux玩家，想必也说不出个所以然来。\n\n  3、dispatch是同步的，而且dispatch没办法确认action是否执行成功\n3.了解 redux 么，说一下 redux 把\n\n1.vue和react的区别\n")])])]),e("p",[n._v("2.react性能优化的方案\n    3.React 项目用过什么脚手架\n    4.介绍一下webpack webpack")]),n._v(" "),e("p",[n._v("6.为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？\n7.all、apply以及bind函数内部实现是怎么样的\nFunction.prototype.bind = function(thisArg) {\nif(typeof this !== 'function'){\nthrow new TypeError(this + 'must be a function');\n}\n// 存储函数本身\nconst _this  = this;\n// 去除thisArg的其他参数 转成数组\nconst args = [...arguments].slice(1)\n// 返回一个函数\nconst bound = function() {\n// 可能返回了一个构造函数，我们可以 new F()，所以需要判断\nif (this instanceof bound) {\nreturn new _this(...args, ...arguments)\n}\n// apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果\nreturn _this.apply(thisArg, args.concat(...arguments))\n}\nreturn bound\n}\n8.Canvas和SVG有什么区别\nSVG\n　　　　SVG 是一种使用 XML 描述 2D 图形的语言。\n　　　　SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。\n　　　　在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n　　　　特点：\n　　　　\t　　不依赖分辨率\n　　　　\t　　支持事件处理器\n　　　　\t　　最适合带有大型渲染区域的应用程序（比如谷歌地图）\n　　　　　　\t复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n　　　　\t　　不适合游戏应用\n　　Canvas\n　　　　Canvas 通过 JavaScript 来绘制 2D 图形。\n　　　　Canvas 是逐像素进行渲染的。\n　　　　在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。\n　　　　特点：\n　　　    　　依赖分辨率\n　　　　\t　　不支持事件处理器\n　　　　　　\t弱的文本渲染能力\n　　　　　　\t能够以 .png 或 .jpg 格式保存结果图像\n　　　　\t　　最适合图像密集型的游戏，其中的许多对象会被频繁重绘")]),n._v(" "),e("p",[n._v("https://www.jianshu.com/p/e9521f78d51e\nhttp://www.sohu.com/a/228045621_647584\nhttps://www.cnblogs.com/Yanss/p/10135405.html\nhttps://www.jianshu.com/p/4357c4ae99eb\nhttps://segmentfault.com/a/1190000015648248?utm_source=tag-newest")])])}),[],!1,null,null,null);t.default=a.exports}}]);